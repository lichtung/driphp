# Publish/Subscribe
In the previous tutorial we created a work queue. The assumption behind a work queue is that each
task is delivered to exactly one worker. In this part we'll do something completely different --
we'll deliver a message to multiple consumers. This pattern is known as "publish/subscribe".
之前的章节介绍的是每个消息传递给特定的消费者，而这一章讲的是将消息传递给多个消费者，这种模式就是为人熟知的"分布/订阅"

To illustrate (阐明) the pattern, we're going to build a simple logging system.  
It will consist of two programs -- the first will emit log messages and the second will receive and print them.

In our logging system every running copy of the receiver program will get the messages.
That way we'll be able to run one receiver and direct the logs to disk;
and at the same time we'll be able to run another receiver and see the logs on the screen.
一个接收者负责将日志存盘，一个接收者负责打印日志到屏幕上

Essentially(本质上), published log messages are going to be broadcast to all the receivers.

# Exchanges  交换器
In previous parts of the tutorial we sent and received messages to and from a queue.
Now it's time to introduce the full messaging model in Rabbit.

Let's quickly go over what we covered in the previous tutorials:

- A producer is a user application that sends messages.
- A queue is a buffer that stores messages.
- A consumer is a user application that receives messages.

The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue.
核心思想就是RabbitMQ中的消息模型中，生产者不会直接将消息发送到队列中
Actually, quite often the producer doesn't even know if a message will be delivered to any queue at all.
实际上，生产者甚至不知道消息是否会被加入消息队列中
Instead, the producer can only send messages to an exchange.
生产者只会把消息发送到交换器
An exchange is a very simple thing. On one side it receives messages from producers and the other side it pushes them to queues.
交换器一边接收来自生产者的消息，一边将消息推送到队列中

The exchange must know exactly what to do with a message it receives.
交换器必须清楚地知道接受到消息后的实际操作
Should it be appended to a particular queue?
Should it be appended to many queues?
Or should it get discarded (丢弃的).
The rules for that are defined by the exchange type.
处理规则由交换器的类型决定
There are a few exchange types available: direct, topic, headers and fanout. We'll focus on the last one -- the fanout.
Let's create an exchange of this type, and call it logs:
交换器有以下的几种类型可以使用： direct, topic, headers 和 fanout。我将侧重讲解fanout。让我们创建这种类型，并叫它“logs”
```php
$channel->exchange_declare('logs', 'fanout', false, false, false);
```
The fanout exchange is very simple. As you can probably guess from the name, it just broadcasts all the
messages it receives to all the queues it knows. And that's exactly what we need for our logger.
fanout交换器非常简单，你可以从它的名字中猜到它的用途，它将接收到的消息广播到已知的所有队列中，这正是我们的日志记录器所需要的

The default exchange 默认的交换器
In previous parts of the tutorial we knew nothing about exchanges, but still were able to send messages to queues. That was possible because we were using a default exchange, which we identify by the empty string ("").
教程中前面讲到的章节中我们还不知道交换器的概念，但是仍然能发布消息到队列中，这是因为我们使用了一个默认的交换器，它的标识符是空字符串
Recall how we published a message before:
回顾之前发布消息的过程：
```php
$channel->basic_publish($msg, '', 'hello');
```
Here we use the default or nameless exchange: messages are routed to the queue with the name specified by routing_key, if it exists. The routing key is the third argument to basic_publish
这里我们使用了一个无名的交换器（参数二指定）：消息被路由到routing_key声明的队列中
Now, we can publish to our named exchange instead:
现在我们可以发布消息到命名的交换器中了
```php
$channel->exchange_declare('logs', 'fanout', false, false, false);
$channel->basic_publish($msg, 'logs');
```
Temporary queues 临时队列
As you may remember previously we were using queues which had a specified name (remember hello and task_queue?).
我们之前使用的队列都有特定的名称
Being able to name a queue was crucial(重要的) for us -- we needed to point the workers to the same queue.
声明队列名称是重要的，只有这样我们才能将消费者指定到相同的队列里

Giving a queue a name is important when you want to share the queue between producers and consumers.
当你想要在生产者和消费者之间分享队列时，给一个队列起名是很重要的
But that's not the case for our logger. We want to hear about all log messages, not just a subset of them.
但这不适合我们的日记记录器，我们想要监听所有的日志消息，而不是部分日志消息
We're also interested only in currently flowing messages not in the old ones.
我们也只关心当前流动中的消息而不是旧的消息
To solve that we need two things.
为解决这个问题，我们需要两件事物。
Firstly, whenever we connect to Rabbit we need a fresh(全新的), empty queue.
To do this we could create a queue with a random name, or, even better - let the server choose a random queue name for us.
首先，创建一个随机名称的队列，或者让服务器为我们选择一个随机的名称
Secondly, once we disconnect the consumer the queue should be automatically deleted.
其次，当我们的消费者从服务器断开连接时，队列自动销毁

In the php-amqplib client, when we supply queue name as an empty string, we create a non-durable queue with a generated name:
在php-amqplib客户端中，当我们用空的名称创建队列时就得到了一个随机名称的队列
```php
list($queue_name, ,) = $channel->queue_declare("");
```
When the method returns, the $queue_name variable contains a random queue name generated by RabbitMQ. For example it may look like amq.gen-JzTY20BRgKO-HjmUJj0wLg.

When the connection that declared it closes, the queue will be deleted because it is declared as exclusive.
You can learn more about the exclusive flag and other queue properties in the guide on queues.
当连接被声明为关闭的时候，队列会因为删除，因为它是被特殊声明的。

Bindings
We've already created a fanout exchange and a queue. Now we need to tell the exchange to send messages to our queue. That relationship between exchange and a queue is called a binding.
交换器和队列之间的关系叫绑定
```php
$channel->queue_bind($queue_name, 'logs');
```

Putting it all together
The producer program, which emits log messages, doesn't look much different from the previous tutorial. The most important change is that we now want to publish messages to our logs exchange instead of the nameless one. Here goes the code for emit_log.php script:
这里的生产者程序和之前介绍的并未有太多区别，除了最大的改变-我们发布消息到特定的交换器而不是匿名的交换器。
```php

require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
$channel = $connection->channel();
# 指定exchange
$channel->exchange_declare('logs', 'fanout', false, false, false);

$data = implode(' ', array_slice($argv, 1));
if(empty($data)) $data = "info: Hello World!";
$msg = new AMQPMessage($data);

$channel->basic_publish($msg, 'logs');

echo " [x] Sent ", $data, "\n";

$channel->close();
$connection->close();

```
As you see, after establishing the connection we declared the exchange. This step is necessary as publishing to a non-existing exchange is forbidden.

The messages will be lost if no queue is bound to the exchange yet, but that's okay for us; if no consumer is listening yet we can safely discard the message.
如果没有队列绑定到交换中心，消息就会丢失，但这对我来说没有问题。如果没有消费者在监听，这个消息就可以丢弃（对于日志系统）
The code for receive_logs.php:
```php

require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPStreamConnection;

$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
$channel = $connection->channel();

# 声明exchange，同emit_log.php
$channel->exchange_declare('logs', 'fanout', false, false, false);

# 匿名队列，用完即废
list($queue_name, ,) = $channel->queue_declare("", false, false, true, false);
# 绑定队列到exchange
$channel->queue_bind($queue_name, 'logs');

echo ' [*] Waiting for logs. To exit press CTRL+C', "\n";

$callback = function($msg){
  echo ' [x] ', $msg->body, "\n";
};

$channel->basic_consume($queue_name, '', false, true, false, false, $callback);

while(count($channel->callbacks)) {
    $channel->wait();
}

$channel->close();
$connection->close();
```
